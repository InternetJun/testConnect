## 归并排序
适用对一个有遗留一个全部的比较的情况
~~~ java
while(p1< m || p2 < n) {
	if(p1 > m) {
	}else if(p2 >n) {
	
	}else if(nums1[p1] > nums2[p2]) {
	}else {
	}
}
~~~
## 字母的周围不相同
[重构字母](https://leetcode-cn.com/problems/reorganize-string/)
**当时我的问题是：当字母排序到了最后的时候呢？代码的实现**   
分为了even和odd种情况。它的放置的位置是有讲究的。可以模拟的。奇数必须在偶数的位置上。
~~~ java
//它是肯定会用到的是先填充odd的位置的。后面再去使用奇数的位置了。很有趣的东西！
while(oddInd < n) {
	oddInd += 2;
}
~~~
