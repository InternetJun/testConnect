# 程序的难点和基本点

## <font color='red'>堆排序</font>

<font color = "blue">VIP:black_heart:和那个插入排序一样的思路.</font>

~~~ java
public void adjust(int[] nums, int i, int len) {
    for(int k = 2*i +1; k < len; k = 2*k+1){//为什么这样？，因为的是处理的叶子节点了。
        //因为我们比较的是左右叶子节点的内容大小的。
    }
}
~~~

### 自己实现线段树的内容：

最多可以参见的会议和线段树有什么的关系？[1,2],[2,3],[3,4];-->1,2,3,4;

~~~ java
 int[] nums = {1, 3, 5, 7, 9, 11};
~~~

今天的有一个的是对相同数的异或^;

有什么的知识？1，二分；2，递归的问题。

`1`: 实现构造树的过程；

有的是对递归来说，自己要想的是一定会有结果的。递归的出口是if（L==R）tree[node] = nums[L];

`2`：对arr[idx(4)] = val(6);

他的过程还是有一的。L==R==》update

`3`:  搜索的过程呢？

有在范围内，直接是返回数据。不要递归下去。还有相等的情况

## <font color='red'>希尔排序</font>

~~~ java
//太美了.
pubilc void sort(int[] nums){
	int len = nums.length;
	//要实现的是一个希尔排序，有利用的是插入排序知识了。
	for(int i = len/2; i > 0; i /= 2) {
		for(j = i; j < len; j++) {
			int m = j;//他的是和要插入的元素是一样的。
			int tmp = nums[m];
			if(nums[m] < nums[m-i]) //要升序的问题了。
			{
				//利用tmp就很好，是一个动态的过程。
				while(m- i > 0 && tmp < nums[m-i]) {
					nums[j] = nums[m-i];
					m -=  i;
				}
				nums[m] = tmp;
			}
		}
	}
}
~~~

## insertSort

~~~ java
public void insertSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        insertVal = nums[i];
        insertIndex = i-1;
        while(insertVal < nums[i]) {
            nums[insertIndex+1] = nums[insertIndex];
            insertIndex--;
        }
         nums[insertIndex+1] = insertVal;
    }
}
~~~



## 图的无向

我想求出每个点到其他点所有和:

<font color = "red" background = "black">dp[u]:代表了u节点的根子树数目；</font>

<font color = "red" background = "black">sz[u]:代表了子树的节点数目啊；</font>
$$
\textit{dp}[u]=\sum_{v\in \textit{son}[u]}\textit{dp}[v] + \textit{sz}[v]\\
\text{son[u] is the union of u}
$$


动态规划的思想做的；更新的原则是什么？

>1. 在更新一点的时候呢，反转结果；很难！！
>2. 是可以这么考虑，对dp[u]去除v的影响后，u是v的子集了，这时可以有dp[v]加上对u的贡献；
>3. 如下图所示的那样：我们有dp[1]+1+dp[2]+3==>dp[1] = 1, dp[2] = 3;

![1601963936310](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1601963936310.png)

1.在列表内保存全部链接的信息的实现：

~~~ java
List ls;
public void getAdj(int N, int[] nums){
    ls = new List<>;
    for(int i = 0; i < N; i++){
        ls.add(new List);
    }
    
    for(int[] num : nums){
        int u = num[0], v = num[1];
        ls.get(u).add(v);
        ls.get(v).add(u);//这是无向图很重要的点啊！
    }
}
~~~

2.每个点到其他点路径的总和是可以利用的，因为是相互的！

~~~ java
 public void dfs(int u, int f) {
    sz[u] = 1;
    dp[u] = 0;
    for(int v: graph.get(u)){
        if(v==f)
            continue;
        dfs(v,u);
        dp[u]+=dp[v]+sz[v];//得到一个(节点的所有的信息！
        sz[u] += sz[v];
    }
}

public void dfs2(int u, int f){
    ans[u] = dp[u];
    
}
~~~

## 并查集

可以知道节点的祖宗；对岛屿问题的动态连接实现了。

~~~ java
public class Test{
 	private int[] islands;
    public int root(int island) {
        while(islands[island] != island) {
            islands[island] = islands[islands[island]];
            island = islands[island];
        }
        return island;
    }
}
~~~

自己去实现对班级一共几类朋友的实现；

~~~ java

~~~

### union Find（很优雅）

~~~ java
class UF {
    
    private int count;
    
    private int[] parent;
    
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
~~~

------

1. 判定合法等式

union Find是有自反性，传递性，对称性；

if(connect(x,y)) {

​	return false;

}

2. 计算有几类

   union后呢？对parent数组统计；if parent == -1: count++;

   <font color="red">不是很懂</font>

3. 计算过程（岛屿的依次加入点）<font color='red'>什么意思呢？</font>

~~~ java
在判断上下左右前对island赋值，但是会忽略掉的是水的元素，还有的是对UDLR的加入同一个的root中，
~~~

上下左右依次的判断；

if(islands[nid] != -1) {

​	int root = root(nid);

​	if(root != id) {

​		islands[root] = id;

​		island--;

​	}

}

## 环形的证明

![1602207660911](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602207660911.png)
$$
f: a+n \times (b+c) + b\\
s:a+b\\
f = 2\times s\\
a = (n-1)\times(b+c)+c\\
\text{从链表头到入口和meet point触发一定要相遇的！}
$$

## 数学的应用（BitMask）

2^n的计算技巧：要模拟出进位和一些的内容了

[迅雷笔试](https://www.nowcoder.com/test/question/done?tid=38602552&qid=247558#summary)

<font color='red'>四舍五入：Math.round();</font>

 根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易记忆：

1、参数的小数点后第一位<5，运算结果为参数整数部分。
2、参数的小数点后第一位>5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。

-11.8> ==>-12;  11.6==>>12

<font color='orange'>3、参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分</font>

<font color='red'>对负数的处理，需要的是-3/5==》-1：</font>

需要如下的处理 ，-3/5-1;还有的是math的四舍五入的东西，有

原码反码补码：

~~~ java
    -15：
    原码：1 1111  --> -15
    反码：1 0000  -->  0
    补码：1 0001   --> -1
~~~

还有的是应用了。

只出现一次的数字，有2个数字出现了1次，其余的2次：

 `bitmask & (-bitmask)` 保留 `bitmask` 最右边的 `1` 

~~~ java
// 我们可以直接从 bitmask 中提取 x 和 y 吗？不能，但是我们可以用 bitmask 作为标记来分离 x 和 y。我们通过 bitmask & (-bitmask) 保留 bitmask 最右边的 1，这个 1 要么来自 x，要么来自 y。

class Solution {
  public int[] singleNumber(int[] nums) {
    // difference between two numbers (x and y) which were seen only once
    int bitmask = 0;
    for (int num : nums) 
        bitmask ^= num;

    // rightmost 1-bit diff between x and y
    int diff = bitmask & (-bitmask);

    int x = 0;
    // bitmask which will contain only x
    for (int num : nums) 
        if ((num & diff) != 0) 
            x ^= num;

    return new int[]{x, bitmask^x};
  }
}
~~~

**bitmask&(-bitmask)得到的就是<font color="red">*bitmask*</font>****最右一位1。因为存储的是每一个数的补码。**

例如有【4，6，2，2】；**异或的规则是不同就1，相同的话是0；**

bitmask初始值为0；--bitmask值是2；

## 桶排序的应用

1. 在一个nums中有几个要求，i-j <=k,nums[i]-nums[j] <= t;

<font color='red'>有Java中，‘-3/5 = 0’, 但需要‘-3/5=-1’;</font>

~~~java
 // Get the ID of the bucket from element value x and bucket width w
    // In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.
    private long getID(long x, long w) {
        return x < 0 ? (x + 1) / w - 1 : x / w;
    }

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (t < 0) return false;
        Map<Long, Long> d = new HashMap<>();
        long w = (long)t + 1;
        for (int i = 0; i < nums.length; ++i) {
            long m = getID(nums[i], w);
            // check if bucket m is empty, each bucket may contain at most one element
            if (d.containsKey(m))
                return true;
            // check the nei***or buckets for almost duplicate
            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)
                return true;
            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)
                return true;
            // now bucket m is empty and no almost duplicate in nei***or buckets
            d.put(m, (long)nums[i]);
            //这句话很有意思，要的是对于nums的下标没有超过i+k的限制的
            if (i >= k) 
                d.remove(getID(nums[i - k], w));
        }
        return false;
    }
~~~

<font color='red'>//这句话很有意思，要的是对于nums的下标没有超过i+k的限制的
            if (i >= k) d.remove(getID(nums[i - k], w));</font>

## 动态规划

01背包的2分集合


$$
dp[i][j]=dp[i-1][j] \text{ }||\text{ } dp[i-1][j-nums[i]]
$$

~~~ java
//是有2部分的：
    if(j >= nums[i]) {
        //可以不选择or选择
       dp[i][j] = dp[i-1][j]||dp[i-1][j-nums[i]]
    }else{
        dp[i][j] = dp[i-1][j];
    }
~~~

## 逆波兰表达式

<font color="red">题目说要求有嵌套的存在，其实他后缀就已经处理了，VIP</font>

## 对套接的表达式取里面的内容

## 有循环嵌套的存在

有三种葡萄，每种分别有 `a, b, c` 颗，现在有三个人，第一个人只吃第一种和第二种葡萄，第二个人只吃第二种和第三种葡萄，第三个人只吃第一种和第三种葡萄。

<font color = “red">M/N, 数据的向上取整。是有（M+(N-1)）/N的小技巧。</font>

现在给你输入 `a, b, c` 三个值，请你适当安排，让三个人吃完所有的葡萄，算法返回**吃的最多的人最少要吃多少颗葡萄**？
$$
\left\{ \begin{array}{c}
	a+b \ge c, (a+b+c+2)/3\\
	a+b<c,(c+1)/2\\
\end{array} \right.
$$

## 括号的生成

问题是有2种的解法，有要回溯的和不要回溯的。

但断点的情况是代码实现了在计算机内部要做的事。

<font color="blue">有2种的表示:</font>

~~~ java
//1.
if(left<0||right<0) {
    return;
}
if(left < right) {
    return;
}
dfs(...);
//2.
if(left > 0) {
    dfs(left-1);
}

if(right > left) {
dfs(right-1);
}
    
~~~

## 最短路径

1）djistack

2）bfs的实现了。

1. 直接最短。？求出来。
2. 给定一个限制，求可能达到终点？

## 连续与间断的子序列

1. 连续的时候：滑动的窗口；

   ~~~ java
   //怎么保存最长的结果？abcdefg？
   /*1 没有重复的时候直接很简单的。
     2 有重复的时候
   	1. 最大的时候是在第一个的时候呢？
       2.最大的时候不是第一个
   */
   
   //保存所有的结果Map；
   
   //获取一个结果
   if(right+1-i > ans) {
       sb.delete();
       sb.append();
   }else if(){
       continue;
   }
   ~~~
   
   
   
2. 间断的时候

~~~ java
int count;
for(){
    if(inStack)
        continue;
    while(){
        if(count[peek] == 0){
            break
        }
        inStack[c]=false;       
    }
    stack.push();
    inStack = true;
}
~~~

## 单例模式

1.饿汉式

~~~  java
public class Singleton{
    private static final Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
~~~

2.DCL(很重要的知识，面试的概率太大了。)

~~~ java
public class Singleton{
    private  static volatile Singleton instance = null;
    private Singleton(){
        
    }
    public static Singleton getInstance(){
        if(instance == null) {
            Synchronized (Singleton.class) {
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~

3.枚举

~~~ java
/**
 * Title：Singleton<br>
 * Description：单例模式——枚举方式
 * 
 * @author QiuChangjin
 * @date 2018年4月17日
 */
public enum  EnumSingleton {
    INSTANCE;
    public EnumSingleton getInstance(){
        return INSTANCE;
    }
}
~~~

## 计算任意两个节点的最小差

![1602472924545](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602472924545.png)

~~~ java
//有定义的时候，第一个想法是中序遍历先存储；
//后面的是
if(pre = -1){
    pre = root.val;
}else {
    //这里的pre是前一个的判断了，还有root是下一个的，真实代表的是root.right;
    min = Math.min(root.val - pre);
    pre = root.val;
}
~~~

## log4j的优先级

DEBUG < <font color="red">*INFO*</font> < WARN < ERROR < FATAL;

 **groupId**  , **artifactId**, <font color='red'>version</font>;是maven的三大元素；

## 寻找重复子树

1. 我自己为根张什么样子？

   A:后序遍历，左+右+自己；

2. 别人是什么样子？

   用的是序列化的东西了。一切都逃不过我们。

## 反转list

~~~ java
listNode pre, cur, next;
//需要注意的是有些的东西是指针。
while(cur!= null) {
    next = cur.next;
    cur.next = pre;
    
    //update;
    pre = cur;
    next = cur;
}
~~~

## <font color='red'>携程的知识点</font>

[答案](F:\workspace\someProblem\src\test\携程\Main.java)

### <font color='orange'>贪心</font>

有要对 m个可乐，a个100，b个50，c个10块。还有x块的可乐。要几次的花钱（<font color='cornflowerblue'>每次一张钱</font>）？

![1602573777135](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602573777135.png)

和搜狗的题目很类似的。需要考虑的问题了。

~~~ java
//依次把100，50，10块的东西用完的意思了。
1. 只有a*100 > x;
2. a*100 + b*50 > x;
3. a*100+b*50+c*10 > x;
~~~

### <font color='orange'>正则表达式（太久没用了）</font>

可以在一边了。后面在看了。

一些的规则，不是很懂啊。

\bhi\b --> hi;

\bhi\b.*\bLucy\b;

<font color='red'>需要转换的特殊字符：</font>

 \\ 反斜杠
\t 间隔 ('\u0009')
\n 换行 ('\u000A')
\r 回车 ('\u000D')
\d 数字 等价于 [0-9]
\D 非数字 等价于 [^0-9]
\s 空白符号 [\t\n\x0B\f\r]
\S 非空白符号 [^\t\n\x0B\f\r]
\w 单独字符 [a-zA-Z_0-9]
\W 非单独字符 [^a-zA-Z_0-9]
\f 换页符
\e Escape
\b 一个单词的边界
\B 一个非单词的边界
\G 前一个匹配的结束 

~~~ java
(    [     {    /    ^    -    $     ¦    }    ]    )    ?    *    +    .
~~~

| .    | 匹配除换行符以外的任意字符   |
| ---- | ---------------------------- |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

### 取大值的题目

对坐标和val的表现了.

### 斜着遍历的动态规划

1. 回文串；

   1）回文子序列；

   ~~~ java
   [1, 2, 3, 3, 4]
   [0, 1, 2, 2, 3]
   [0, 0, 1, 1, 3]
   [0, 0, 0, 1, 1]
   [0, 0, 0, 0, 1]
   //要的结果
   ~~~

   2）回文子串；

   他们有什么的不同？子序列是对于s[i] == s[n-i]?；子串是有长度的。他们的解法是不同的。

   ~~~ java
   //有l的长度。i，j的表达。
   ~~~

   3）子串内容最长的无重复的（滑动窗口的应用）

   还要使用set辅助工具。一般这样的子串长度是要有左右2个指针的。不是说的就一个的

2. 对于动态规划博弈的内容；

## 22交换（ListNode）

![1602639526336](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602639526336.png)

代码实现

~~~ java
public ListNode swap(ListNode head) {
    if(head == null || head.next == null) {
        return null;
    }
    ListNode newHead = head.next;
    head.next = swap(newHead.next);
    newHead.next = head;
}    
~~~

<font color='orange'>滴滴字符的交换，有点不同的思想。</font>

有点变换的意思：

![1603242120270](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1603242120270.png)

他用的是线性表的实现了，List<ListNode> : ls.addd(node);

~~~ java
while(node != null) {
    node = node.next;
    ls.add();
}
int i = 0, j = len;
while(i < j) {
    if(i == j){
        break;
    }
    //要注意的是有i++是先加的，还有的是对最后的一个元素要
}
ls.get(i).next = null;
这是必须的，不然的话没有完整性的。
~~~

## 要求的有矩阵的杨氏搜索

$$
\begin{matrix}
	1&	2	&	3	\\
	3&	5	&	6	\\
	6&	8	&	9	\\
\end{matrix}
$$

思路是对最下角开始到右上角的查找了。复杂度是O(m+n)

## 二分查找

1，在一个数组内，有m个组，让m组内的最大和最小。要有边界

可以转换的是一个？值最大中有多个的m满足，找出最小满足的情况！

~~~ java
可能的取值是什么？最大和：[max(arr), sum(arr)];因为有一个和多个的情况啊。
for(max : sum(arr)) {
    
}
//怎么把一个数组分为多个？
public int split(int[] nums, int tar) {
    int count = 1;int sum = 0;
    for(){
        if(sum + nusm[i] > tar) {
            count++;
            sum = tar;
        }else {
            sum+= nums[i];
        }
    }
}
~~~



2，查找出左侧的值和右侧的值；

~~~ java
有while(left<right);right = nums.length;
终止条件是left = right；
while(left <= right)==>终止的调试是left= right+1；
    
~~~

<font color='red'>他的一些下推的边界是有递推的。会一直到结束搜索的；</font>

### 左边界

~~~ java
int r = nums.length;
//[left, right);
while(l < r) {
    int mid = (l+r)/2;
    if(nums[l] = target) {
        right = mid;
    }else if(nums[l] > target) {
        right = mid;
    } else{
        left = mid+1;
    }
}
~~~

### 右边界

~~~ java
int r = nums.length;
while(l<r) {
    int mid;
    if(nums[mid] == target) {
        left = mid+1;//注意
    }else if(nums[mid] < target) {
        left = mid+1;
    } else{
        right = mid
    }
}
return left-1;//注意,要是没有呢？
if(边界||nums[left-1] != target) {
    return -1;
}
~~~

<font color='orange'>首先明白l == r是退出的条件。所以你要为了体现右侧可以right-1；</font>

<font color='red'>为什么需要减1呢？</font>

left = mid +1解释：

 当`nums[mid] == target`时，不要立即返回，而是增大「搜索区间」的下界`left`，使得区间不断向右收缩，达到锁定右侧边界的目的。



<font color='orange'>结果：至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</font>

```
if (nums[mid] == target) {    left = mid + 1;    // 这样想: mid = left - 1
```

## 数组排序

1. 最大的子序列和

`1 -3 6`

~~~ java
for(int i = 1; i<len; i++) {
    nums[i] += Math.max(nums[i-1], 0);
    res = Math.max(nums[i], res);
}
~~~

2. <font color='red'>在排序中只允许随机数放在最后一位。（这是一个重点，不是很懂！）</font>

[有趣的排序](https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a)

~~~ javascript
//给了一个有趣的思路，先拍好序，对没有在位置上的就要移动了。
可能是我表述的不太好。举个例子 现在有 3  6  1  4  2  5 这个序列 ，那么 1  跟 2 是不用移动的。我们先把 3移动到最后，此时变成  6  1  4  2  5  3  ，再把  4 移动到 最后 就变成 6  1  2  5  3  4  接着移动 5 到最后就变成 6  1  2  3  4  5 就变成 6  1  2  3  4  5  ，最后移动 6 变成我们需要的 1  2  3  4  5  6
~~~

2. 一道压缩字符串题和字符的张开实现？

这个很基础吧。但是对于数字多位的话需要有

~~~ java
//10;
int temp = 0;
for(int i = 0; i<s.length; i++) {
    if(s.charAt(i) >='0' && s.charAt(i)<='9'){
        temp += temp*10 + Integer.valueOf(c);
    }
}
~~~

## 基本算法

### 插入排序

是一个无序和有序的列表，有序的是对无序的依次的进行比较。最后有序的变为了真正的有序的。

17  3 25 14 20 9；-->

(3 17)3插在17的前面；

### 选择排序

8 3 2 1 7 4 6 5；

第一次选择最小值在`0~n-1`内，与arr[0]交换；。。。

归并排序

## 关键字continue, break

他是可以对流程的控制的。

毋庸置疑，在switch case 语句中不能使用continue 关键字。continue语句的作用是跳出本次循环，转入执行下一次循环。故而，continue语句只能用于循环语句中，而switch case语句为多分支选择语句，不是循环语句，所以在switch case 语句中是不能使用continue 关键字的(除非把continue关键字放在循环语句中)；

### break

对一个字符处理的实验，发现了友趣的现象，

对ab###处理，如下2种代码：

~~~ java
	for(int i : len) {
        if(c == '#') {
            //todo
            break;
        }
    }
//====================
	for(int i : len) {
        if(c == '#') {
            //todo
            continue;
        }
    }
~~~

==> 出现了break的时候，有剩余a，直接退出了循环；但是continue呢是结束了本轮的循环>==

## 计算时间的控制

![1603086322323](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1603086322323.png)

判断质数的代码？1和本身被除，其他的就没有了。

~~~ java
public boolean isPrim(int n){
    if(n%i == 0) {
        return false;
    }
    return true;
}
	
for(int i = 2; i < n; i++) {
    if(isPrim(i)) {
        for(int j = i*i; j < n; j+=i) 			 {
            isPrim[j] = false;
        }
    }
}
}
~~~

## 模拟2数相乘和进位实现

~~~ java
//上层的函数有
public String compute(int n) {
    if(n==1){
        return "2";
    }
    String tmp = compute(n/2);//递归--》
}

for(int i : len){
    for(int j : len1) {
        mul = s[i]*s1[j];
        int p1 = i+j, p2 = i+j+1;
        int sum = mul+ans[p2];
        ans[p1] += sum/10;//求进位的问题了。
        ans[p2] =  sum%10;//求余的计算
    }
}
//有的是
if(inter[i][0] > right) {
    left+right;
    left;//update;
    right;//update;
} else if(){
    right = ;
}
res += left+"," + right;
sout(res);
~~~

### 全排列，组合，字典序的区别

1，全排列中不允许有重复的

~~~ java
//需要有only one的东西的时候呢?zai if(used[i]){}
if(!used[i]){
    used[i] = true;
    path.add();
    dfs();
    used[i] = false
	path.remove();        
}
~~~

2, 字典序的内容

~~~ java
if(val > maxValue) {
    return;
}

if(num > 0) {
    ls.add(num);
}
for(int i =start > 0 ? 0 : 1 ;i<=9; i++)
            dfs(maxValue, num*10+i, start+1);
//原因的话就是有每次都加上1的，不是说其他的问题。
~~~

3，组合的问题，其实还是回溯的问题。

~~~ java
if(n== k) {
    //todo
}
~~~

## 字符的比较问题

eg：asek与aaseek；分别是name和type的东西；

有的是说利用了双指针了。<font color= "green”>快慢</font>

~~~ java
while(equal){
	if ==
    i++,j++;
	if(j-1 == j) {
        j++;
    }
    index == len ? true: false;
}
~~~

### 回文的判断

1，每一个的字符都是说的是回文的。

~~~ Java
while(l <= r) {
    if(s.charAt(l) != s.charAt(r)){
        return false;
    }
    
}
return true;
~~~

## z字形的变换

有的时候是需要对问题另一种的思路了。

~~~ java
//对数据的变换。
class Solution {
    public String convert(String s, int numRows) {
        if(numRows < 2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i = 0; i < numRows; i++) 
            rows.add(new StringBuilder());
        int i = 0, flag = -1;
        for(char c : s.toCharArray()) {
            rows.get(i).append(c);
            if(i == 0 || i == numRows -1) 
                flag = - flag;
            i += flag;
        }
        StringBuilder res = new StringBuilder();
        for(StringBuilder row : rows) 
            res.append(row);
        return res.toString();
    }
}
~~~

## 回文的全部的组合

~~~ java

//别忘了 i<=ji<=j，所以只用填半张表，如下图。
public int countSubString(String s) {
    boolean[][] dp = new boolean[s.length][s.length];
    int ans = 0;
    for(int i : s(len)) {
        if(s.charAt(i) == s.charAt(j) && (j -i < 2 || 
                                         dp[][] = true)) {
            dp[][] = true;
            ans++;
        }
    }
}
~~~

## 1024节日快乐

Q1024对拼接视频的最短视频个数

利用贪心来做题目. 有的是说,

~~~ java
public int videoStich(int[][] clips, int T) {
    int[] maxn = new int[T];
    int last = 0, res = 0, pre = 0;
    for(int[] clip : clips){
        if(clip[0] < T){
            //jiushi 对每一个的i有保存的是最长的区间啊.
            maxn[clip[0]] = 
        }
    }
}
~~~

<font color= “red">Q:**很难:**怎么把中序变为后序的表达式呢? 还有的是可以把String变为一个ls的数组的.</font>

## 字节跳动(难)

1. rgb的转2进制.

   <font color="red">负二进制转化:</font>

2. 对于数字的变化问题. 他是神那么的情况?

~~~ java
//跟你一样的思路，但是只过了75%. 不知道为什么，思路就是先判断如果所有人都是0或者1的话就是不行，否则，就遍历一遍，记录相同衣服的最大长度，然后加一再除以2就是稳定天数，然后时尚学生数就是总人数减去（相同衣服长度为偶数的个数乘以2）。就只能过75好难受啊
~~~

## LRU

他的删除和update的操作是什么？

1，update的时候判断我们的size == capacity？

​	1）cache.removeLast(); map.remtove(last.key);

​	2）cache.addFirst(x); map.put(key, x);

因为是新加入的点。<font color='red'>所以要放入的是map中</font>。相当于数据库的东西。



 git remote add  someProblem https://github.com/InternetJun/SomeThink.git

### 他的子问题.

需要的是删除, insert, get都是O(1)的复杂度的问题:

remove的操作是, swap(i, len-1);

<font color='red'>要改的东西有什么?</font>

>delete one of the val;
>
>1, 交换元素后last和idx的元素是要判断的.
>
>有几种特殊的情况, 
>
>size() == 0的时候就直接去remove();
>
>删除的数据不是最后一个元素的时候呢?就会直接去删除。

<font color='cornflowerblue'>最后一个元素的删除包含了几个动作（1，delete map‘s index；2，加入map的lastNum；3，delete map的index；4，删除原来的lastNum）2删1加入，list的最后一个元素删除；</font>

## 类的问题

~~~ java
Collections.sort(intervals, new Compartor(){
    @Overrride
    public void compare() {
        //...
    }
})
~~~

1103的题目：对一个山峰数列的判断；

~~~ java
public boolean is Mountain(int nums) {
    int index = 0;
    while(index < nums.length) {
        while() {
            index++;
        }
        //其实就是极限的位置的
        if(index == 0 || index == len-1){
            return false;
        }
        while()  {
          index++;
        }
    }
    return index == len-1;
}
~~~

=======
# 程序的难点和基本点

## <font color='red'>堆排序</font>

<font color = "blue">VIP:black_heart:和那个插入排序一样的思路.</font>

~~~ java
public void adjust(int[] nums, int i, int len) {
    for(int k = 2*i +1; k < len; k = 2*k+1){//为什么这样？，因为的是处理的叶子节点了。
        //因为我们比较的是左右叶子节点的内容大小的。
    }
}
~~~

### 自己实现线段树的内容：

最多可以参见的会议和线段树有什么的关系？[1,2],[2,3],[3,4];-->1,2,3,4;

~~~ java
 int[] nums = {1, 3, 5, 7, 9, 11};
~~~

今天的有一个的是对相同数的异或^;

有什么的知识？1，二分；2，递归的问题。

`1`: 实现构造树的过程；

有的是对递归来说，自己要想的是一定会有结果的。递归的出口是if（L==R）tree[node] = nums[L];

`2`：对arr[idx(4)] = val(6);

他的过程还是有一的。L==R==》update

`3`:  搜索的过程呢？

有在范围内，直接是返回数据。不要递归下去。还有相等的情况

## <font color='red'>希尔排序</font>

~~~ java
//太美了.
pubilc void sort(int[] nums){
	int len = nums.length;
	//要实现的是一个希尔排序，有利用的是插入排序知识了。
	for(int i = len/2; i > 0; i /= 2) {
		for(j = i; j < len; j++) {
			int m = j;//他的是和要插入的元素是一样的。
			int tmp = nums[m];
			if(nums[m] < nums[m-i]) //要升序的问题了。
			{
				//利用tmp就很好，是一个动态的过程。
				while(m- i > 0 && tmp < nums[m-i]) {
					nums[j] = nums[m-i];
					m -=  i;
				}
				nums[m] = tmp;
			}
		}
	}
}
~~~

## insertSort

~~~ java
public void insertSort(int[] nums) {
    for (int i = 0; i < nums.length; i++) {
        insertVal = nums[i];
        insertIndex = i-1;
        while(insertVal < nums[i]) {
            nums[insertIndex+1] = nums[insertIndex];
            insertIndex--;
        }
         nums[insertIndex+1] = insertVal;
    }
}
~~~



## 图的无向

我想求出每个点到其他点所有和:

<font color = "red" background = "black">dp[u]:代表了u节点的根子树数目；</font>

<font color = "red" background = "black">sz[u]:代表了子树的节点数目啊；</font>
$$
\textit{dp}[u]=\sum_{v\in \textit{son}[u]}\textit{dp}[v] + \textit{sz}[v]\\
\text{son[u] is the union of u}
$$


动态规划的思想做的；更新的原则是什么？

>1. 在更新一点的时候呢，反转结果；很难！！
>2. 是可以这么考虑，对dp[u]去除v的影响后，u是v的子集了，这时可以有dp[v]加上对u的贡献；
>3. 如下图所示的那样：我们有dp[1]+1+dp[2]+3==>dp[1] = 1, dp[2] = 3;

![1601963936310](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1601963936310.png)

1.在列表内保存全部链接的信息的实现：

~~~ java
List ls;
public void getAdj(int N, int[] nums){
    ls = new List<>;
    for(int i = 0; i < N; i++){
        ls.add(new List);
    }
    
    for(int[] num : nums){
        int u = num[0], v = num[1];
        ls.get(u).add(v);
        ls.get(v).add(u);//这是无向图很重要的点啊！
    }
}
~~~

2.每个点到其他点路径的总和是可以利用的，因为是相互的！

~~~ java
 public void dfs(int u, int f) {
    sz[u] = 1;
    dp[u] = 0;
    for(int v: graph.get(u)){
        if(v==f)
            continue;
        dfs(v,u);
        dp[u]+=dp[v]+sz[v];//得到一个(节点的所有的信息！
        sz[u] += sz[v];
    }
}

public void dfs2(int u, int f){
    ans[u] = dp[u];
    
}
~~~

## 并查集

可以知道节点的祖宗；对岛屿问题的动态连接实现了。

~~~ java
public class Test{
 	private int[] islands;
    public int root(int island) {
        while(islands[island] != island) {
            islands[island] = islands[islands[island]];
            island = islands[island];
        }
        return island;
    }
}
~~~

自己去实现对班级一共几类朋友的实现；

~~~ java

~~~

### union Find（很优雅）

~~~ java
class UF {
    
    private int count;
    
    private int[] parent;
    
    private int[] size;

    public UF(int n) {
        this.count = n;
        parent = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }
    
    public void union(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        if (rootP == rootQ)
            return;
        
        
        if (size[rootP] > size[rootQ]) {
            parent[rootQ] = rootP;
            size[rootP] += size[rootQ];
        } else {
            parent[rootP] = rootQ;
            size[rootQ] += size[rootP];
        }
        count--;
    }

    public boolean connected(int p, int q) {
        int rootP = find(p);
        int rootQ = find(q);
        return rootP == rootQ;
    }

    private int find(int x) {
        while (parent[x] != x) {
            
            parent[x] = parent[parent[x]];
            x = parent[x];
        }
        return x;
    }

    public int count() {
        return count;
    }
}
~~~

------

1. 判定合法等式

union Find是有自反性，传递性，对称性；

if(connect(x,y)) {

​	return false;

}

2. 计算有几类

   union后呢？对parent数组统计；if parent == -1: count++;

   <font color="red">不是很懂</font>

3. 计算过程（岛屿的依次加入点）<font color='red'>什么意思呢？</font>

~~~ java
在判断上下左右前对island赋值，但是会忽略掉的是水的元素，还有的是对UDLR的加入同一个的root中，
~~~

上下左右依次的判断；

if(islands[nid] != -1) {

​	int root = root(nid);

​	if(root != id) {

​		islands[root] = id;

​		island--;

​	}

}

## 环形的证明

![1602207660911](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602207660911.png)
$$
f: a+n \times (b+c) + b\\
s:a+b\\
f = 2\times s\\
a = (n-1)\times(b+c)+c\\
\text{从链表头到入口和meet point触发一定要相遇的！}
$$

## 数学的应用（BitMask）

2^n的计算技巧：要模拟出进位和一些的内容了

[迅雷笔试](https://www.nowcoder.com/test/question/done?tid=38602552&qid=247558#summary)

<font color='red'>四舍五入：Math.round();</font>

 根据上面例子的运行结果，我们还可以按照如下方式总结，或许更加容易记忆：

1、参数的小数点后第一位<5，运算结果为参数整数部分。
2、参数的小数点后第一位>5，运算结果为参数整数部分绝对值+1，符号（即正负）不变。

-11.8> ==>-12;  11.6==>>12

<font color='orange'>3、参数的小数点后第一位=5，正数运算结果为整数部分+1，负数运算结果为整数部分</font>

<font color='red'>对负数的处理，需要的是-3/5==》-1：</font>

需要如下的处理 ，-3/5-1;还有的是math的四舍五入的东西，有

原码反码补码：

~~~ java
    -15：
    原码：1 1111  --> -15
    反码：1 0000  -->  0
    补码：1 0001   --> -1
~~~

还有的是应用了。

只出现一次的数字，有2个数字出现了1次，其余的2次：

 `bitmask & (-bitmask)` 保留 `bitmask` 最右边的 `1` 

~~~ java
// 我们可以直接从 bitmask 中提取 x 和 y 吗？不能，但是我们可以用 bitmask 作为标记来分离 x 和 y。我们通过 bitmask & (-bitmask) 保留 bitmask 最右边的 1，这个 1 要么来自 x，要么来自 y。

class Solution {
  public int[] singleNumber(int[] nums) {
    // difference between two numbers (x and y) which were seen only once
    int bitmask = 0;
    for (int num : nums) 
        bitmask ^= num;

    // rightmost 1-bit diff between x and y
    int diff = bitmask & (-bitmask);

    int x = 0;
    // bitmask which will contain only x
    for (int num : nums) 
        if ((num & diff) != 0) 
            x ^= num;

    return new int[]{x, bitmask^x};
  }
}
~~~

**bitmask&(-bitmask)得到的就是<font color="red">*bitmask*</font>****最右一位1。因为存储的是每一个数的补码。**

例如有【4，6，2，2】；**异或的规则是不同就1，相同的话是0；**

bitmask初始值为0；--bitmask值是2；

## 桶排序的应用

1. 在一个nums中有几个要求，i-j <=k,nums[i]-nums[j] <= t;

<font color='red'>有Java中，‘-3/5 = 0’, 但需要‘-3/5=-1’;</font>

~~~java
 // Get the ID of the bucket from element value x and bucket width w
    // In Java, `-3 / 5 = 0` and but we need `-3 / 5 = -1`.
    private long getID(long x, long w) {
        return x < 0 ? (x + 1) / w - 1 : x / w;
    }

    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {
        if (t < 0) return false;
        Map<Long, Long> d = new HashMap<>();
        long w = (long)t + 1;
        for (int i = 0; i < nums.length; ++i) {
            long m = getID(nums[i], w);
            // check if bucket m is empty, each bucket may contain at most one element
            if (d.containsKey(m))
                return true;
            // check the nei***or buckets for almost duplicate
            if (d.containsKey(m - 1) && Math.abs(nums[i] - d.get(m - 1)) < w)
                return true;
            if (d.containsKey(m + 1) && Math.abs(nums[i] - d.get(m + 1)) < w)
                return true;
            // now bucket m is empty and no almost duplicate in nei***or buckets
            d.put(m, (long)nums[i]);
            //这句话很有意思，要的是对于nums的下标没有超过i+k的限制的
            if (i >= k) 
                d.remove(getID(nums[i - k], w));
        }
        return false;
    }
~~~

<font color='red'>//这句话很有意思，要的是对于nums的下标没有超过i+k的限制的
            if (i >= k) d.remove(getID(nums[i - k], w));</font>

## 动态规划

01背包的2分集合


$$
dp[i][j]=dp[i-1][j] \text{ }||\text{ } dp[i-1][j-nums[i]]
$$

~~~ java
//是有2部分的：
    if(j >= nums[i]) {
        //可以不选择or选择
       dp[i][j] = dp[i-1][j]||dp[i-1][j-nums[i]]
    }else{
        dp[i][j] = dp[i-1][j];
    }
~~~

## 逆波兰表达式

<font color="red">题目说要求有嵌套的存在，其实他后缀就已经处理了，VIP</font>

## 对套接的表达式取里面的内容

## 有循环嵌套的存在

有三种葡萄，每种分别有 `a, b, c` 颗，现在有三个人，第一个人只吃第一种和第二种葡萄，第二个人只吃第二种和第三种葡萄，第三个人只吃第一种和第三种葡萄。

<font color = “red">M/N, 数据的向上取整。是有（M+(N-1)）/N的小技巧。</font>

现在给你输入 `a, b, c` 三个值，请你适当安排，让三个人吃完所有的葡萄，算法返回**吃的最多的人最少要吃多少颗葡萄**？
$$
\left\{ \begin{array}{c}
	a+b \ge c, (a+b+c+2)/3\\
	a+b<c,(c+1)/2\\
\end{array} \right.
$$

## 括号的生成

问题是有2种的解法，有要回溯的和不要回溯的。

但断点的情况是代码实现了在计算机内部要做的事。

<font color="blue">有2种的表示:</font>

~~~ java
//1.
if(left<0||right<0) {
    return;
}
if(left < right) {
    return;
}
dfs(...);
//2.
if(left > 0) {
    dfs(left-1);
}

if(right > left) {
dfs(right-1);
}
    
~~~

## 最短路径

1）djistack

2）bfs的实现了。

1. 直接最短。？求出来。
2. 给定一个限制，求可能达到终点？

## 连续与间断的子序列

1. 连续的时候：滑动的窗口；

   ~~~ java
   //怎么保存最长的结果？abcdefg？
   /*1 没有重复的时候直接很简单的。
     2 有重复的时候
   	1. 最大的时候是在第一个的时候呢？
       2.最大的时候不是第一个
   */
   
   //保存所有的结果Map；
   
   //获取一个结果
   if(right+1-i > ans) {
       sb.delete();
       sb.append();
   }else if(){
       continue;
   }
   ~~~
   
   
   
2. 间断的时候

~~~ java
int count;
for(){
    if(inStack)
        continue;
    while(){
        if(count[peek] == 0){
            break
        }
        inStack[c]=false;       
    }
    stack.push();
    inStack = true;
}
~~~

## 单例模式

1.饿汉式

~~~  java
public class Singleton{
    private static final Singleton instance = new Singleton();
    private Singleton(){}
    public static Singleton getInstance(){
        return instance;
    }
}
~~~

2.DCL(很重要的知识，面试的概率太大了。)

~~~ java
public class Singleton{
    private  static volatile Singleton instance = null;
    private Singleton(){
        
    }
    public static Singleton getInstance(){
        if(instance == null) {
            Synchronized (Singleton.class) {
                if(instance == null){
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
~~~

3.枚举

~~~ java
/**
 * Title：Singleton<br>
 * Description：单例模式——枚举方式
 * 
 * @author QiuChangjin
 * @date 2018年4月17日
 */
public enum  EnumSingleton {
    INSTANCE;
    public EnumSingleton getInstance(){
        return INSTANCE;
    }
}
~~~

## 计算任意两个节点的最小差

![1602472924545](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602472924545.png)

~~~ java
//有定义的时候，第一个想法是中序遍历先存储；
//后面的是
if(pre = -1){
    pre = root.val;
}else {
    //这里的pre是前一个的判断了，还有root是下一个的，真实代表的是root.right;
    min = Math.min(root.val - pre);
    pre = root.val;
}
~~~

## log4j的优先级

DEBUG < <font color="red">*INFO*</font> < WARN < ERROR < FATAL;

 **groupId**  , **artifactId**, <font color='red'>version</font>;是maven的三大元素；

## 寻找重复子树

1. 我自己为根张什么样子？

   A:后序遍历，左+右+自己；

2. 别人是什么样子？

   用的是序列化的东西了。一切都逃不过我们。

## 反转list

~~~ java
listNode pre, cur, next;
//需要注意的是有些的东西是指针。
while(cur!= null) {
    next = cur.next;
    cur.next = pre;
    
    //update;
    pre = cur;
    next = cur;
}
~~~

## <font color='red'>携程的知识点</font>

[答案](F:\workspace\someProblem\src\test\携程\Main.java)

### <font color='orange'>贪心</font>

有要对 m个可乐，a个100，b个50，c个10块。还有x块的可乐。要几次的花钱（<font color='cornflowerblue'>每次一张钱</font>）？

![1602573777135](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602573777135.png)

和搜狗的题目很类似的。需要考虑的问题了。

~~~ java
//依次把100，50，10块的东西用完的意思了。
1. 只有a*100 > x;
2. a*100 + b*50 > x;
3. a*100+b*50+c*10 > x;
~~~

### <font color='orange'>正则表达式（太久没用了）</font>

可以在一边了。后面在看了。

一些的规则，不是很懂啊。

\bhi\b --> hi;

\bhi\b.*\bLucy\b;

<font color='red'>需要转换的特殊字符：</font>

 \\ 反斜杠
\t 间隔 ('\u0009')
\n 换行 ('\u000A')
\r 回车 ('\u000D')
\d 数字 等价于 [0-9]
\D 非数字 等价于 [^0-9]
\s 空白符号 [\t\n\x0B\f\r]
\S 非空白符号 [^\t\n\x0B\f\r]
\w 单独字符 [a-zA-Z_0-9]
\W 非单独字符 [^a-zA-Z_0-9]
\f 换页符
\e Escape
\b 一个单词的边界
\B 一个非单词的边界
\G 前一个匹配的结束 

~~~ java
(    [     {    /    ^    -    $     ¦    }    ]    )    ?    *    +    .
~~~

| .    | 匹配除换行符以外的任意字符   |
| ---- | ---------------------------- |
| \w   | 匹配字母或数字或下划线或汉字 |
| \s   | 匹配任意的空白符             |
| \d   | 匹配数字                     |
| \b   | 匹配单词的开始或结束         |
| ^    | 匹配字符串的开始             |
| $    | 匹配字符串的结束             |

### 取大值的题目

对坐标和val的表现了.

### 斜着遍历的动态规划

1. 回文串；

   1）回文子序列；

   ~~~ java
   [1, 2, 3, 3, 4]
   [0, 1, 2, 2, 3]
   [0, 0, 1, 1, 3]
   [0, 0, 0, 1, 1]
   [0, 0, 0, 0, 1]
   //要的结果
   ~~~

   2）回文子串；

   他们有什么的不同？子序列是对于s[i] == s[n-i]?；子串是有长度的。他们的解法是不同的。

   ~~~ java
   //有l的长度。i，j的表达。
   ~~~

   3）子串内容最长的无重复的（滑动窗口的应用）

   还要使用set辅助工具。一般这样的子串长度是要有左右2个指针的。不是说的就一个的

2. 对于动态规划博弈的内容；

## 22交换（ListNode）

![1602639526336](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1602639526336.png)

代码实现

~~~ java
public ListNode swap(ListNode head) {
    if(head == null || head.next == null) {
        return null;
    }
    ListNode newHead = head.next;
    head.next = swap(newHead.next);
    newHead.next = head;
}    
~~~

<font color='orange'>滴滴字符的交换，有点不同的思想。</font>

有点变换的意思：

![1603242120270](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1603242120270.png)

他用的是线性表的实现了，List<ListNode> : ls.addd(node);

~~~ java
while(node != null) {
    node = node.next;
    ls.add();
}
int i = 0, j = len;
while(i < j) {
    if(i == j){
        break;
    }
    //要注意的是有i++是先加的，还有的是对最后的一个元素要
}
ls.get(i).next = null;
这是必须的，不然的话没有完整性的。
~~~

## 要求的有矩阵的杨氏搜索

$$
\begin{matrix}
	1&	2	&	3	\\
	3&	5	&	6	\\
	6&	8	&	9	\\
\end{matrix}
$$

思路是对最下角开始到右上角的查找了。复杂度是O(m+n)

## 二分查找

1，在一个数组内，有m个组，让m组内的最大和最小。要有边界

可以转换的是一个？值最大中有多个的m满足，找出最小满足的情况！

~~~ java
可能的取值是什么？最大和：[max(arr), sum(arr)];因为有一个和多个的情况啊。
for(max : sum(arr)) {
    
}
//怎么把一个数组分为多个？
public int split(int[] nums, int tar) {
    int count = 1;int sum = 0;
    for(){
        if(sum + nusm[i] > tar) {
            count++;
            sum = tar;
        }else {
            sum+= nums[i];
        }
    }
}
~~~



2，查找出左侧的值和右侧的值；

~~~ java
有while(left<right);right = nums.length;
终止条件是left = right；
while(left <= right)==>终止的调试是left= right+1；
    
~~~

<font color='red'>他的一些下推的边界是有递推的。会一直到结束搜索的；</font>

### 左边界

~~~ java
int r = nums.length;
//[left, right);
while(l < r) {
    int mid = (l+r)/2;
    if(nums[l] = target) {
        right = mid;
    }else if(nums[l] > target) {
        right = mid;
    } else{
        left = mid+1;
    }
}
~~~

### 右边界

~~~ java
int r = nums.length;
while(l<r) {
    int mid;
    if(nums[mid] == target) {
        left = mid+1;//注意
    }else if(nums[mid] < target) {
        left = mid+1;
    } else{
        right = mid
    }
}
return left-1;//注意,要是没有呢？
if(边界||nums[left-1] != target) {
    return -1;
}
~~~

<font color='orange'>首先明白l == r是退出的条件。所以你要为了体现右侧可以right-1；</font>

<font color='red'>为什么需要减1呢？</font>

left = mid +1解释：

 当`nums[mid] == target`时，不要立即返回，而是增大「搜索区间」的下界`left`，使得区间不断向右收缩，达到锁定右侧边界的目的。



<font color='orange'>结果：至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：</font>

```
if (nums[mid] == target) {    left = mid + 1;    // 这样想: mid = left - 1
```

## 数组排序

1. 最大的子序列和

`1 -3 6`

~~~ java
for(int i = 1; i<len; i++) {
    nums[i] += Math.max(nums[i-1], 0);
    res = Math.max(nums[i], res);
}
~~~

2. <font color='red'>在排序中只允许随机数放在最后一位。（这是一个重点，不是很懂！）</font>

[有趣的排序](https://www.nowcoder.com/questionTerminal/adc291e7e79f452c8b59243a5ce68d3a)

~~~ javascript
//给了一个有趣的思路，先拍好序，对没有在位置上的就要移动了。
可能是我表述的不太好。举个例子 现在有 3  6  1  4  2  5 这个序列 ，那么 1  跟 2 是不用移动的。我们先把 3移动到最后，此时变成  6  1  4  2  5  3  ，再把  4 移动到 最后 就变成 6  1  2  5  3  4  接着移动 5 到最后就变成 6  1  2  3  4  5 就变成 6  1  2  3  4  5  ，最后移动 6 变成我们需要的 1  2  3  4  5  6
~~~

2. 一道压缩字符串题和字符的张开实现？

这个很基础吧。但是对于数字多位的话需要有

~~~ java
//10;
int temp = 0;
for(int i = 0; i<s.length; i++) {
    if(s.charAt(i) >='0' && s.charAt(i)<='9'){
        temp += temp*10 + Integer.valueOf(c);
    }
}
~~~

## 基本算法

### 插入排序

是一个无序和有序的列表，有序的是对无序的依次的进行比较。最后有序的变为了真正的有序的。

17  3 25 14 20 9；-->

(3 17)3插在17的前面；

### 选择排序

8 3 2 1 7 4 6 5；

第一次选择最小值在`0~n-1`内，与arr[0]交换；。。。

归并排序

## 关键字continue, break

他是可以对流程的控制的。

毋庸置疑，在switch case 语句中不能使用continue 关键字。continue语句的作用是跳出本次循环，转入执行下一次循环。故而，continue语句只能用于循环语句中，而switch case语句为多分支选择语句，不是循环语句，所以在switch case 语句中是不能使用continue 关键字的(除非把continue关键字放在循环语句中)；

### break

对一个字符处理的实验，发现了友趣的现象，

对ab###处理，如下2种代码：

~~~ java
	for(int i : len) {
        if(c == '#') {
            //todo
            break;
        }
    }
//====================
	for(int i : len) {
        if(c == '#') {
            //todo
            continue;
        }
    }
~~~

==> 出现了break的时候，有剩余a，直接退出了循环；但是continue呢是结束了本轮的循环>==

## 计算时间的控制

![1603086322323](C:\Users\lejun\AppData\Roaming\Typora\typora-user-images\1603086322323.png)

判断质数的代码？1和本身被除，其他的就没有了。

~~~ java
public boolean isPrim(int n){
    if(n%i == 0) {
        return false;
    }
    return true;
}
	
for(int i = 2; i < n; i++) {
    if(isPrim(i)) {
        for(int j = i*i; j < n; j+=i) 			 {
            isPrim[j] = false;
        }
    }
}
}
~~~

## 模拟2数相乘和进位实现

~~~ java
//上层的函数有
public String compute(int n) {
    if(n==1){
        return "2";
    }
    String tmp = compute(n/2);//递归--》
}

for(int i : len){
    for(int j : len1) {
        mul = s[i]*s1[j];
        int p1 = i+j, p2 = i+j+1;
        int sum = mul+ans[p2];
        ans[p1] += sum/10;//求进位的问题了。
        ans[p2] =  sum%10;//求余的计算
    }
}
//有的是
if(inter[i][0] > right) {
    left+right;
    left;//update;
    right;//update;
} else if(){
    right = ;
}
res += left+"," + right;
sout(res);
~~~

### 全排列，组合，字典序的区别

1，全排列中不允许有重复的

~~~ java
//需要有only one的东西的时候呢?zai if(used[i]){}
if(!used[i]){
    used[i] = true;
    path.add();
    dfs();
    used[i] = false
	path.remove();        
}
~~~

2, 字典序的内容

~~~ java
if(val > maxValue) {
    return;
}

if(num > 0) {
    ls.add(num);
}
for(int i =start > 0 ? 0 : 1 ;i<=9; i++)
            dfs(maxValue, num*10+i, start+1);
//原因的话就是有每次都加上1的，不是说其他的问题。
~~~

3，组合的问题，其实还是回溯的问题。

~~~ java
if(n== k) {
    //todo
}
~~~

## 字符的比较问题

eg：asek与aaseek；分别是name和type的东西；

有的是说利用了双指针了。<font color= "green”>快慢</font>

~~~ java
while(equal){
	if ==
    i++,j++;
	if(j-1 == j) {
        j++;
    }
    index == len ? true: false;
}
~~~

### 回文的判断

1，每一个的字符都是说的是回文的。

~~~ Java
while(l <= r) {
    if(s.charAt(l) != s.charAt(r)){
        return false;
    }
    
}
return true;
~~~

## z字形的变换

有的时候是需要对问题另一种的思路了。

~~~ java
//对数据的变换。
class Solution {
    public String convert(String s, int numRows) {
        if(numRows < 2) return s;
        List<StringBuilder> rows = new ArrayList<StringBuilder>();
        for(int i = 0; i < numRows; i++) 
            rows.add(new StringBuilder());
        int i = 0, flag = -1;
        for(char c : s.toCharArray()) {
            rows.get(i).append(c);
            if(i == 0 || i == numRows -1) 
                flag = - flag;
            i += flag;
        }
        StringBuilder res = new StringBuilder();
        for(StringBuilder row : rows) 
            res.append(row);
        return res.toString();
    }
}
~~~

## 回文的全部的组合

~~~ java

//别忘了 i<=ji<=j，所以只用填半张表，如下图。
public int countSubString(String s) {
    boolean[][] dp = new boolean[s.length][s.length];
    int ans = 0;
    for(int i : s(len)) {
        if(s.charAt(i) == s.charAt(j) && (j -i < 2 || 
                                         dp[][] = true)) {
            dp[][] = true;
            ans++;
        }
    }
}
~~~

## 1024节日快乐

Q1024对拼接视频的最短视频个数

利用贪心来做题目. 有的是说,

~~~ java
public int videoStich(int[][] clips, int T) {
    int[] maxn = new int[T];
    int last = 0, res = 0, pre = 0;
    for(int[] clip : clips){
        if(clip[0] < T){
            //jiushi 对每一个的i有保存的是最长的区间啊.
            maxn[clip[0]] = 
        }
    }
}
~~~

<font color= “red">Q:**很难:**怎么把中序变为后序的表达式呢? 还有的是可以把String变为一个ls的数组的.</font>

## 字节跳动(难)

1. rgb的转2进制.

   <font color="red">负二进制转化:</font>

2. 对于数字的变化问题. 他是神那么的情况?

~~~ java
//跟你一样的思路，但是只过了75%. 不知道为什么，思路就是先判断如果所有人都是0或者1的话就是不行，否则，就遍历一遍，记录相同衣服的最大长度，然后加一再除以2就是稳定天数，然后时尚学生数就是总人数减去（相同衣服长度为偶数的个数乘以2）。就只能过75好难受啊
~~~

## LRU

他的删除和update的操作是什么？

1，update的时候判断我们的size == capacity？

​	1）cache.removeLast(); map.remtove(last.key);

​	2）cache.addFirst(x); map.put(key, x);

因为是新加入的点。<font color='red'>所以要放入的是map中</font>。相当于数据库的东西。



 git remote add  someProblem https://github.com/InternetJun/SomeThink.git

### 他的子问题.

需要的是删除, insert, get都是O(1)的复杂度的问题:

remove的操作是, swap(i, len-1);

<font color='red'>要改的东西有什么?</font>

>delete one of the val;
>
>1, 交换元素后last和idx的元素是要判断的.
>
>有几种特殊的情况, 
>
>size() == 0的时候就直接去remove();
>
>删除的数据不是最后一个元素的时候呢?就会直接去删除。

<font color='cornflowerblue'>最后一个元素的删除包含了几个动作（1，delete map‘s index；2，加入map的lastNum；3，delete map的index；4，删除原来的lastNum）2删1加入，list的最后一个元素删除；</font>

## 类的问题

~~~ java
Collections.sort(intervals, new Compartor(){
    @Overrride
    public void compare() {
        //...
    }
})
~~~

1103的题目：对一个山峰数列的判断；

~~~ java
public boolean is Mountain(int nums) {
    int index = 0;
    while(index < nums.length) {
        while() {
            index++;
        }
        //其实就是极限的位置的
        if(index == 0 || index == len-1){
            return false;
        }
        while()  {
          index++;
        }
    }
    return index == len-1;
}
~~~

## 区间的问题：合并，剪切

1. 合并的是对另一个的start > 要比较的start了。
2. <font color='red'>剪切的还是需要我们的最长的末尾的元素。其实对于片段来说，必定是大于0的。就是说last > pre的。</font>

~~~ java
//具体地，我们枚举每一个位置，假设当枚举到位置 ii 时，记左端点不大于 ii 的所有子区间的最远右端点为 \textit{last}last。这样 \textit{last}last 就代表了当前能覆盖到的最远的右端点。
for(int i : nums) {
    if( i == last ) { //? {
        return -1;//想表示的是什么？
        //// 当前元素 = 本区间最大元素(无法到达后续位置)
        
    }
}
~~~

